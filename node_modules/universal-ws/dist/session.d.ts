/// <reference types="node" />
import { EventEmitter } from 'events';
import * as retry from 'retry';
import { StatusCode } from './transport';
import { PerMessageDeflateOptions } from 'ws';
export { StatusCode } from './transport';
declare enum ReservedPacketTypes {
    Heartbeat = "hb",
    HeartbeatRequest = "hbr",
    NegotiateSettings = "ns"
}
export interface StandardPacket {
    t?: ReservedPacketTypes | string;
    m: string;
    d: any;
    r?: boolean | string;
    i: string;
}
export interface SupportedOptions {
    heartbeatModes?: Set<HeartbeatMode> | HeartbeatMode[];
    minHeartbeatInterval?: number;
    maxHeartbeatInterval?: number;
}
export declare enum HeartbeatMode {
    upstream = "upstream",
    downstream = "downstream",
    roundtrip = "roundtrip",
    disabled = "disabled"
}
export declare enum State {
    connecting = 0,
    open = 1,
    closing = 2,
    closed = 3
}
export interface ConnectionOptions {
    connectionTimeout?: number;
    responseTimeout?: number;
    heatbeatInterval?: number;
    heartbeatMode?: HeartbeatMode;
    heartbeatModeTimeoutMultiplier?: number | (() => number);
    autoConnect?: boolean;
    perMessageDeflateOptions?: PerMessageDeflateOptions;
    retryOptions?: retry.OperationOptions;
    retryConnectionStatusCodes?: number[];
}
export declare class Session extends EventEmitter {
    private host;
    private transport?;
    private heartbeatPolling;
    private expires?;
    private waiting?;
    private rpcTransactions;
    private connectionTimeout;
    responseTimeout: number;
    private parameters?;
    private heartbeatModeTimeoutMultiplier;
    private autoConnect;
    private perMessageDeflateOptions?;
    private retryOptions;
    private retryConnectionStatusCodes;
    private connectOperation?;
    heatbeatInterval: number;
    heartbeatMode: HeartbeatMode;
    state: State;
    constructor(host: string, options?: ConnectionOptions, ...parameters: string[]);
    private changeState;
    private resetAndAttemptConnectOperation;
    private connect;
    private connectionReady;
    private startHeartbeat;
    private stopHeartbeat;
    private awaitReady;
    private resetTimeout;
    private getPacketType;
    private handleClose;
    private resolveErrorFromCloseEvent;
    private handleError;
    private handleMessage;
    private onConnectionActive;
    private onConnectionInactive;
    private onNegotiateSettings;
    private onMessage;
    private onRequest;
    private onResponse;
    private onAcknowledgement;
    private sendHeartbeat;
    private requestHeartbeat;
    private messageIdSeed;
    private getNextMessageId;
    negotiate(settings: {
        heartbeatMode?: HeartbeatMode;
        heartbeatInterval?: number;
    }): Promise<{
        approve: boolean;
        supportedOptions?: SupportedOptions | undefined;
    }>;
    send(message: string, data?: any): void;
    sendWithAck(message: string, data?: any): Promise<{}>;
    request<T = any>(message: string, data?: any): Promise<T>;
    close(code?: StatusCode | number, reason?: string): void;
    open(): Error | undefined;
}
//# sourceMappingURL=session.d.ts.map